/*! Monio: io-event-stream.mjs
    v0.8.1 (c) 2021 Kyle Simpson
    MIT License: http://getify.mit-license.org
*/
import{isFunction,curry}from"./lib/util.mjs";import IO from"./io.mjs";export default curry(ioEventStream);export{merge};export{zip};export{close};function ioEventStream(e,t,r={}){var{bufferSize:n=100,throwBufferOverflow:i=!1,evtOpts:l={}}=r;return IO((()=>{var r,o;return async function*eventStream(){r=[],o=[],isFunction(e.addEventListener)?e.addEventListener(t,handler,l):isFunction(e.addListener)?e.addListener(t,handler):isFunction(e.on)&&e.on(t,handler);try{for(;;){if(0==r.length){let{pr:e,next:t}=getDeferred();r.push(e),o.push(t)}yield r.shift()}}finally{isFunction(e.removeEventListener)?e.removeEventListener(t,handler,l):isFunction(e.removeListener)?e.removeListener(t,handler):isFunction(e.off)&&e.off(t,handler),r.length=o.length=0}}();function handler(e){if(o.length>0){o.shift()(e)}else if(r.length<n){let{pr:t,next:n}=getDeferred();r.push(t),n(e)}else if(i){let t=new Error("Event stream buffer overflow");throw t.evt=e,t}}}))}function merge(...e){return IO((()=>async function*mergeStreams(){try{for(;;){let t=pullFromStreams(e);if(!(t.length>0))return;try{if(1==t.length){let[r,n,i]=await t[0];if(i.done)return void(e[r]=null);e[r]=n,yield i.value}else{let[r,n,i]=await Promise.race(t);e[r]=null,i.done||(e.push(n),yield i.value)}}catch(e){return Promise.reject(e)}}}finally{await close(e)}}()))}function zip(...e){return IO((()=>async function*zipStreams(){try{for(;;){let t=pullFromStreams(e);if(!(t.length>0))return;try{let r=(await Promise.all(t)).reduce((function getStreamVals(t,r){var[n,i,l]=r;return l.done?(e[n]=null,t):(e[n]=i,[...t,l.value])}),[]);if(!(r.length>0))return;yield r}catch(e){return Promise.reject(e)}}}finally{await close(...e).run()}}()))}function pullFromStreams(e){return e.map((function callIter(t,r){return t&&"function"==typeof t.next?(e[r]=async function getNext(){var n=t.next();try{let i=await n;return e[r]=[r,t,i]}catch(t){return e[r]=null,n}}(),e[r]):t})).filter(Boolean)}function close(...e){return IO((()=>Promise.all(e.map((async function closeStream(e){if(e&&"function"==typeof e.return)try{return await e.return()}catch(e){}})))))}function getDeferred(){var e;return{pr:new Promise((t=>e=t)),next:e}}