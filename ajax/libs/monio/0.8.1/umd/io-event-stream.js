/*! Monio: io-event-stream.js
    v0.8.1 (c) 2021 Kyle Simpson
    MIT License: http://getify.mit-license.org
*/
!function UMD(e,t,n,r){"function"==typeof define&&define.amd?(n=Object.keys(n).map((e=>e.replace(/^\.\//,""))),define(e,n,r)):"undefined"!=typeof module&&module.exports?(n=Object.keys(n).map((e=>require(e))),module.exports=r(...n)):(n=Object.values(n).map((e=>t[e])),t[e]=r(...n))}("IOEventStream","undefined"!=typeof globalThis?globalThis:"undefined"!=typeof global?global:"undefined"!=typeof window?window:"undefined"!=typeof self?self:new Function("return this")(),{"./lib/util.js":"MonioUtil","./io.js":"IO"},(function DEF(e,t){"use strict";var{isFunction:n,curry:r}=e;let l={};function pullFromStreams(e){return e.map((function callIter(t,n){return t&&"function"==typeof t.next?(e[n]=async function getNext(){var r=t.next();try{let l=await r;return e[n]=[n,t,l]}catch(t){return e[n]=null,r}}(),e[n]):t})).filter(Boolean)}function close(...e){return t((()=>Promise.all(e.map((async function closeStream(e){if(e&&"function"==typeof e.return)try{return await e.return()}catch(e){}})))))}function getDeferred(){var e;return{pr:new Promise((t=>e=t)),next:e}}return l=r((function ioEventStream(e,r,l={}){var{bufferSize:i=100,throwBufferOverflow:o=!1,evtOpts:a={}}=l;return t((()=>{var t,l;return async function*eventStream(){t=[],l=[],n(e.addEventListener)?e.addEventListener(r,handler,a):n(e.addListener)?e.addListener(r,handler):n(e.on)&&e.on(r,handler);try{for(;;){if(0==t.length){let{pr:e,next:n}=getDeferred();t.push(e),l.push(n)}yield t.shift()}}finally{n(e.removeEventListener)?e.removeEventListener(r,handler,a):n(e.removeListener)?e.removeListener(r,handler):n(e.off)&&e.off(r,handler),t.length=l.length=0}}();function handler(e){if(l.length>0){l.shift()(e)}else if(t.length<i){let{pr:n,next:r}=getDeferred();t.push(n),r(e)}else if(o){let t=new Error("Event stream buffer overflow");throw t.evt=e,t}}}))})),l.merge=function merge(...e){return t((()=>async function*mergeStreams(){try{for(;;){let t=pullFromStreams(e);if(!(t.length>0))return;try{if(1==t.length){let[n,r,l]=await t[0];if(l.done)return void(e[n]=null);e[n]=r,yield l.value}else{let[n,r,l]=await Promise.race(t);e[n]=null,l.done||(e.push(r),yield l.value)}}catch(e){return Promise.reject(e)}}}finally{await close(e)}}()))},l.zip=function zip(...e){return t((()=>async function*zipStreams(){try{for(;;){let t=pullFromStreams(e);if(!(t.length>0))return;try{let n=(await Promise.all(t)).reduce((function getStreamVals(t,n){var[r,l,i]=n;return i.done?(e[r]=null,t):(e[r]=l,[...t,i.value])}),[]);if(!(n.length>0))return;yield n}catch(e){return Promise.reject(e)}}}finally{await close(...e).run()}}()))},l.close=close,l}));