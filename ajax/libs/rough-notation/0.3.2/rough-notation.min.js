import{SVG_NS,DEFAULT_ANIMATION_DURATION}from"./model.js";import{renderAnnotation}from"./render.js";import{ensureKeyframes}from"./keyframes.js";import{randomSeed}from"roughjs/bin/math";class RoughAnnotationImpl{constructor(t,i){this._state="unattached",this._resizing=!1,this._seed=randomSeed(),this._lastSizes=[],this._animationDelay=0,this._resizeListener=(()=>{this._resizing||(this._resizing=!0,setTimeout(()=>{this._resizing=!1,"showing"===this._state&&this.haveRectsChanged()&&this.show()},400))}),this._e=t,this._config=JSON.parse(JSON.stringify(i)),this.attach()}get animate(){return this._config.animate}set animate(t){this._config.animate=t}get animationDuration(){return this._config.animationDuration}set animationDuration(t){this._config.animationDuration=t}get iterations(){return this._config.iterations}set iterations(t){this._config.iterations=t}get color(){return this._config.color}set color(t){this._config.color!==t&&(this._config.color=t,this.refresh())}get strokeWidth(){return this._config.strokeWidth}set strokeWidth(t){this._config.strokeWidth!==t&&(this._config.strokeWidth=t,this.refresh())}get padding(){return this._config.padding}set padding(t){this._config.padding!==t&&(this._config.padding=t,this.refresh())}attach(){if("unattached"===this._state&&this._e.parentElement){ensureKeyframes();const t=this._svg=document.createElementNS(SVG_NS,"svg");t.setAttribute("class","rough-annotation");const i=t.style;i.position="absolute",i.top="0",i.left="0",i.overflow="visible",i.pointerEvents="none",i.width="100px",i.height="100px";const e="highlight"===this._config.type;if(this._e.insertAdjacentElement(e?"beforebegin":"afterend",t),this._state="not-showing",e){const t=window.getComputedStyle(this._e).position;(!t||"static"===t)&&(this._e.style.position="relative")}this.attachListeners()}}detachListeners(){window.removeEventListener("resize",this._resizeListener),this._ro&&this._ro.unobserve(this._e)}attachListeners(){this.detachListeners(),window.addEventListener("resize",this._resizeListener,{passive:!0}),!this._ro&&"ResizeObserver"in window&&(this._ro=new window.ResizeObserver(t=>{for(const i of t)i.contentRect&&this._resizeListener()})),this._ro&&this._ro.observe(this._e)}haveRectsChanged(){if(this._lastSizes.length){const t=this.rects();if(t.length!==this._lastSizes.length)return!0;for(let i=0;i<t.length;i++)if(!this.isSameRect(t[i],this._lastSizes[i]))return!0}return!1}isSameRect(t,i){const e=(t,i)=>Math.round(t)===Math.round(i);return e(t.x,i.x)&&e(t.y,i.y)&&e(t.w,i.w)&&e(t.h,i.h)}isShowing(){return"not-showing"!==this._state}refresh(){this.isShowing()&&!this.pendingRefresh&&(this.pendingRefresh=Promise.resolve().then(()=>{this.isShowing()&&this.show(),delete this.pendingRefresh}))}show(){switch(this._state){case"unattached":break;case"showing":this.hide(),this._svg&&this.render(this._svg,!0);break;case"not-showing":this.attach(),this._svg&&this.render(this._svg,!1)}}hide(){if(this._svg)for(;this._svg.lastChild;)this._svg.removeChild(this._svg.lastChild);this._state="not-showing"}remove(){this._svg&&this._svg.parentElement&&this._svg.parentElement.removeChild(this._svg),this._svg=void 0,this._state="unattached",this.detachListeners()}render(t,i){let e=this._config;i&&((e=JSON.parse(JSON.stringify(this._config))).animate=!1);const s=this.rects();let n=0;s.forEach(t=>n+=t.w);const o=e.animationDuration||DEFAULT_ANIMATION_DURATION;let h=0;for(let i=0;i<s.length;i++){const r=s[i];e.animationDuration=o*(r.w/n),renderAnnotation(t,s[i],e,h+this._animationDelay,this._seed),h+=e.animationDuration}this._lastSizes=s,this._state="showing"}rects(){const t=[];if(this._svg)if(this._config.multiline){const i=this._e.getClientRects();for(let e=0;e<i.length;e++)t.push(this.svgRect(this._svg,i[e]))}else t.push(this.svgRect(this._svg,this._e.getBoundingClientRect()));return t}svgRect(t,i){const e=t.getBoundingClientRect(),s=i;return{x:(s.x||s.left)-(e.x||e.left),y:(s.y||s.top)-(e.y||e.top),w:s.width,h:s.height}}}export function annotate(t,i){return new RoughAnnotationImpl(t,i)};export function annotationGroup(t){let i=0;for(const e of t){const t=e;t._animationDelay=i,i+=0===t.animationDuration?0:t.animationDuration||DEFAULT_ANIMATION_DURATION}const e=[...t];return{show(){for(const t of e)t.show()},hide(){for(const t of e)t.hide()}}};