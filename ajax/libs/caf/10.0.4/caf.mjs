/*! caf.mjs
	v10.0.4 (c) 2020 Kyle Simpson
	MIT License: http://getify.mit-license.org
*/

class cancelToken{constructor(n=new AbortController){var e;this.controller=n,this.signal=n.signal;var handleReject=(n,l)=>{var doRej=n=>{l&&(n=this.signal&&this.signal.reason?this.signal.reason:n,l(n),l=null)};this.signal.addEventListener("abort",doRej,!1),e=()=>{this.signal&&(this.signal.removeEventListener("abort",doRej,!1),this.signal.pr&&(this.signal.pr[CLEANUP_FN]=null)),doRej=null}};this.signal.pr=new Promise(handleReject),this.signal.pr[CLEANUP_FN]=e,this.signal.pr.catch(e),handleReject=e=null}abort(n){this.signal&&!("reason"in this.signal)&&(this.signal.reason=n),this.controller&&this.controller.abort()}discard(){this.signal&&(this.signal.pr&&(this.signal.pr[CLEANUP_FN]&&this.signal.pr[CLEANUP_FN](),this.signal.pr=null),this.signal=this.signal.reason=null),this.controller=null}}export default Object.assign(CAF,{cancelToken:cancelToken,delay:delay,timeout:timeout,signalRace:signalRace,signalAll:signalAll});const TIMEOUT_TOKEN=Symbol("Timeout Token"),CLEANUP_FN=Symbol("Cleanup Function");function CAF(n){return function instance(e,...l){var r,i;if(({tokenOrSignal:e,signal:r,signalPr:i}=processTokenOrSignal(e)),r.aborted)return i;var a=i.catch((function onCancelation(n){try{var e=o.return();throw void 0!==e.value?e.value:n}finally{o=s=a=u=null}})),{it:o,result:s}=_runner.call(this,n,r,...l),u=Promise.race([s,a]);if(e!==r&&e[TIMEOUT_TOKEN]){let n=function cancelTimer(){e.abort(),e=n=null};u.then(n,n)}else u.catch((()=>{})),e=null;return r=l=null,u}}function delay(n,e){var l,r;return"number"==typeof n&&"number"!=typeof e&&([e,n]=[n,e]),n&&({tokenOrSignal:n,signal:l,signalPr:r}=processTokenOrSignal(n)),l&&l.aborted?r:new Promise((function c(n,i){l&&(r.catch((function onAbort(){a&&(clearTimeout(a),i(`delay (${e}) interrupted`)),n=i=a=l=null})),r=null);var a=setTimeout((function onTimeout(){n("delayed: "+e),n=i=a=l=null}),e)}))}function timeout(n,e="Timeout"){n=Number(n)||0;var l=new cancelToken;return delay(l.signal,n).then(cleanup,cleanup),Object.defineProperty(l,TIMEOUT_TOKEN,{value:!0,writable:!1,enumerable:!1,configurable:!1}),l;function cleanup(){l.abort(e),l=null}}function signalRace(n){var e=new cancelToken,l=n.map(signalPromise),r=l.map((n=>n[CLEANUP_FN]));return Promise.race(l).catch((function c(n){e.abort(n)})).then((function t(){for(let n of r)n();r=e=null})),e.signal}function signalAll(n){var e=new cancelToken,l=n.map(signalPromise),r=l.map((n=>n[CLEANUP_FN]));return Promise.all(l.map((function m(n){return n.catch((n=>n))}))).then((function t(n){e.abort(n)})).then((function t(){for(let n of r)n();r=e=null})),e.signal}function signalPromise(n){if(n.pr)return n.pr;var e,l=new Promise((function c(l,r){n.addEventListener("abort",r,!1),e=r}));return l[CLEANUP_FN]=function cleanup(){n&&(n.removeEventListener("abort",e,!1),n=null),l&&(l=l[CLEANUP_FN]=e=null)},l.catch(l[CLEANUP_FN]),l}function processTokenOrSignal(n){n instanceof AbortController&&(n=new cancelToken(n));var e=n&&n instanceof cancelToken?n.signal:n;return{tokenOrSignal:n,signal:e,signalPr:signalPromise(e)}}function _runner(n,...e){var l=n.apply(this,e);return n=e=null,{it:l,result:function getNextResult(n){try{var e=l.next(n);n=null}catch(n){return Promise.reject(n)}return function processResult(n){var e=Promise.resolve(n.value);return n.done?l=null:(e=e.then(getNextResult,(function onRejection(n){return Promise.resolve(l.throw(n)).then(processResult)}))).catch((function cleanup(){l=null})),n=null,e}(e)}()}}